const crypto = require('crypto');
const helper = require('../util/helper');
const snekfetch = require('snekfetch');
const { API } = require('./api');

class Client {
    constructor(credentials = {}) {
        if(!(this instanceof Client)) {

            return new Client(credentials);
        }
        
        this.validateConfig(credentials);
        Object.defineProperty(this, 'credentials', {writable: false, value: credentials});
        this.API = new API(this);
    }
    
    async login() {
        const timestamp = Math.floor(new Date().getTime() / 1000).toString();
        let options = {
            include_entities: false,
            /*The oauth_consumer_key identifies which application is making the request. 
            Obtain this value from checking the settings page for your application on apps.twitter.com.*/
            oauth_consumer_key: this.credentials.consumer_key,
            /*The oauth_nonce parameter is a unique token your application should generate for each unique request. 
            Twitter will use this value to determine whether a request has been submitted multiple times. 
            The value for this request was generated by base64 encoding 32 bytes of random data, and stripping out all non-word characters, 
            but any approach which produces a relatively random alphanumeric string should be OK here.*/
            oauth_nonce: helper.randomString(32),
            /*The oauth_signature_method used by Twitter is HMAC-SHA1. 
            This value should be used for any authorized request sent to Twitter’s API.*/
            oauth_signature_method: 'HMAC-SHA1',
            /*The oauth_timestamp parameter indicates when the request was created. 
            This value should be the number of seconds since the Unix epoch at the point the request is generated, 
            and should be easily generated in most programming languages. Twitter will reject requests which were created too far in the past, 
            so it is important to keep the clock of the computer generating requests in sync with NTP.*/
            oauth_timestamp: timestamp,
            /*The oauth_token parameter typically represents a user’s permission to share access to their account with your application. 
            There are a few authentication requests where this value is not passed or is a different form of token, 
            but those are covered in detail in Obtaining access tokens. 
            For most general-purpose requests, you will use what is referred to as an access token.
            You can generate a valid access token for your account on the settings page for your application at apps.twitter.com.*/
            oauth_token: this.credentials.access_token,
            /*The oauth_version parameter should always be 1.0 for any request sent to the Twitter API.*/
            oauth_version: '1.0'
        };
        //extra sorting for if I did it wrong
        options = helper.sortObject(options);
        //making the oauth_signature
        /*Next, gather all of the parameters included in the request. 
        There are two such locations for these additional parameters - the URL (as part of the querystring)
        and the request body. The sample request includes a single parameter in both locations (shown in bold):
        */
        /*In the HTTP request the parameters are URL encoded, but you should collect the raw values. 
        In addition to the request parameters, every oauth_* parameter needs to be included in the signature,
        so collect those too. Here are the parameters from Authorizing a request:
        */
        /*These values need to be encoded into a single string which will be used later on. 
        The process to build the string is very specific:
        Percent encode every key and value that will be signed.
        Sort the list of parameters alphabetically [1] by encoded key [2].
        For each key/value pair:
        - Append the encoded key to the output string.
        - Append the ‘=’ character to the output string.
        - Append the encoded value to the output string.
        - If there are more key/value pairs remaining, append a ‘&’ character to the output string.
        */
        /*
        Note: The OAuth spec says to sort lexigraphically, which is the default alphabetical sort for many libraries. 
        [2]	Note: In case of two parameters with the same encoded key, the OAuth spec says to continue sorting based on value. 
        However, Twitter does not accept duplicate keys in API requests.
        The following string will be produced by repeating these steps with the parameters collected above:
        Parameter string:
        include_entities=true
        &oauth_consumer_key=xvz1evFS4wEEPTGEFPHBog
        &oauth_nonce=kYjzVBB8Y0ZFabxSWbWovY3uYSQ2pTgmZeNu2VS4cg
        &oauth_signature_method=HMAC-SHA1
        &oauth_timestamp=1318622958
        &oauth_token=370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb
        &oauth_version=1.0
        */
        //making the parameter string and uriencoding it
        const paramval = helper.fixedEncodeURIComponent(helper.stringfiller('param', options));
        //urienconding the url for the base signature
        const url = helper.fixedEncodeURIComponent('https://api.twitter.com/1.1/account/verify_credentials.json');
        /*
        The three values collected so far must be joined to make a single string, 
        from which the signature will be generated. 
        This is called the signature base string by the OAuth specification.
        */
        /*
        To encode the HTTP method, base URL, and parameter string into a single string:
        - Convert the HTTP Method to uppercase and set the output string equal to this value.
        - Append the ‘&’ character to the output string.
        - Percent encode the URL and append it to the output string.
        - Append the ‘&’ character to the output string.
        - Percent encode the parameter string and append it to the output string.
        */
        /*
        This will produce the following:
        Signature base string:
        POST&
        https%3A%2F%2Fapi.twitter.com%2F1.1%2Fstatuses%2Fupdate.json
        &include_entities%3Dtrue
        %26oauth_consumer_key%3Dxvz1evFS4wEEPTGEFPHBog
        %26oauth_nonce%3DkYjzVBB8Y0ZFabxSWbWovY3uYSQ2pTgmZeNu2VS4cg
        %26oauth_signature_method%3DHMAC-SHA1
        %26oauth_timestamp%3D1318622958
        %26oauth_token%3D370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb
        %26oauth_version%3D1.0
        */
        /*
        Make sure to percent encode the parameter string!
        The signature base string should contain exactly 2 ampersand ‘&’ characters.
        The percent ‘%’ characters in the parameter string should be encoded as %25 in the signature base string.
        */
        const basesign = `GET&${url}&${paramval}`.replace(/%/g, (c) => '%' + c.charCodeAt(0).toString(16));
        console.log(basesign);
        /*
        The last pieces of data to collect are secrets which identify the application making the request, 
        and the user the request is on behalf of. 
        It is very important to note that these values are incredibly sensitive and should never be shared with anyone.
        The value which identifies your application to Twitter is called the consumer secret and can be found by going
        to apps.twitter.com and viewing the settings page for your application. 
        This will be the same for every request your application sends.
        */
        /*
        The value which identifies the account your application is acting on behalf of is called the oauth token secret.
        This value can be obtained in several ways, all of which are described at Obtaining access tokens.
        Once again, it is very important to keep these values private to your application.
        If you feel that your values have been compromised, 
        regenerate your tokens (the tokens on this page have been marked as invalid for real requests).
        */
        /*
        Both of these values need to be combined to form a signing key
        which will be used to generate the signature. The signing key is simply the percent encoded consumer secret,
        followed by an ampersand character ‘&’, followed by the percent encoded token secret:
        */
        /*
        Note that there are some flows, such as when obtaining a request token, 
        where the token secret is not yet known. 
        In this case, the signing key should consist of the percent encoded consumer secret followed by an ampersand character ‘&’.
        */
        const signkey = `${helper.fixedEncodeURIComponent(this.credentials.consumer_secret)}&${helper.fixedEncodeURIComponent(this.credentials.access_token_secret)}`;
        /*
        Finally, the signature is calculated by passing the signature base string and signing key to the HMAC-SHA1 hashing algorithm.
        The details of the algorithm are explained in depth here, but thankfully there are implementations of HMAC-SHA1 available
        for every popular language. For example, PHP has the hash_hmac function.
        */
        /*
        The output of the HMAC signing function is a binary string.
        This needs to be base64 encoded to produce the signature string.
        For example, the output given the base string and signing key given on this page is 
        84 2B 52 99 88 7E 88 76 02 12 A0 56 AC 4E C2 EE 16 26 B5 49. That value, when converted to base64, is the OAuth signature for this request:
        */
        options.oauth_signature = crypto.createHmac('sha1', signkey).update(basesign).digest('base64');
        options = helper.sortObject(options);
        const headerval = helper.stringfiller('oauthheader', options);
        // console.log(options.signature)
        // console.log(paramval);
        const resp = await snekfetch.get('https://api.twitter.com/1.1/account/verify_credentials.json')
            .set('Accept', '*/*')
            .set(`Authorization`, headerval)
            .set('Connection', 'close')
            .set('Content-Type', 'application/x-www-form-urlencoded')
            .catch(e => console.log(e));
    }
    
    validateConfig(config) {
        if(typeof config !== 'object') {
            throw new TypeError(`The credentials must be an object, now its an ${typeof config}`);
        }
        
        let authType;
        let requiredKeys;
        
        const required_for_app_auth = [
          'consumer_key',
          'consumer_secret'
        ];

        const required_for_user_auth = required_for_app_auth.concat([
          'access_token',
          'access_token_secret'
        ]);
        
        if(config.app_only_auth) {
            authType = 'app-only auth';
            requiredKeys = required_for_app_auth;
        } else {
            authType = 'user auth';
            requiredKeys = required_for_user_auth;
        }
        
        requiredKeys.forEach((key) => {
            if(!config[key]) {
                const errmsg = `The credentials must include ${key} when using ${authType}`;
                throw new Error(errmsg);
            }
        });
    }
}

const client = new Client({
    consumer_key: 'OwbTqMiRZ4CdnXVSYCtb0Iw0C',
    consumer_secret: 'ka3oaRmttoXws0iUpJc3fzFiAX0uCMpsUwC7Qaih8eBrc7e7z8',
    access_token: '1022269892-xCanMkBoleSlsRJ9YgIsv4MF4Gwt1nKpIbOMbbz',
    access_token_secret: 'vZ3edDHFnIyZwFlET30GsqKx9ec6upf4quxyzqElhNzJP'
});

client.login();